import pandas as pd

def profit_exit(cum_rets, limit):
    exit_idx = cum_rets.index[(cum_rets >= limit).argmax()]
    return exit_idx

def stop_loss_exit(cum_rets, limit):
    exit_idx = cum_rets.index[(cum_rets <= limit).argmax()]
    return exit_idx

def calculate_trade(entry_date, returns, pt, sl, tl):
    entry_idx = returns.index.get_loc(entry_date)
    exit_idx = min(entry_idx + tl, len(returns) - 1)
    
    cum_rets = returns.iloc[entry_idx + 1:exit_idx + 1].cumsum()
    
    pt_exit_idx = profit_exit(cum_rets, pt)
    sl_exit_idx = stop_loss_exit(cum_rets, sl)
    
    if not pt_exit_idx or not sl_exit_idx:
        exit_idx = exit_idx
    else:
        exit_idx = min(pt_exit_idx, sl_exit_idx)
    
    return {
        'entry': returns.index[entry_idx],
        'exit': returns.index[entry_idx + exit_idx],
        'ret': cum_rets.iloc[exit_idx - 1],
        'time': exit_idx - 1,
        'maxret': cum_rets.max() - cum_rets.iloc[0]
    }
def calculate_trades(returns, event_dates, pt, sl, tl):
    trades = map(lambda date: calculate_trade(date, returns, pt, sl, tl), event_dates)
    return pd.DataFrame(trades, index=event_dates, columns=['entry', 'exit', 'ret', 'time', 'maxret'])

def triple_barrier_method(returns, event_dates, pt, sl, tl):
    returns = returns.copy()
    trades = calculate_trades(returns, event_dates, pt, sl, tl)
    return trades


import pandas as pd

# Prepare input data
returns = pd.DataFrame({
    'Date': pd.date_range(start='2022-01-01', periods=100),
    'Return': [0.01, -0.02, 0.03, -0.01, 0.02] * 20  # Example daily returns
})

event_dates = pd.to_datetime(['2022-01-05', '2022-01-15', '2022-01-25'])
profit_taking = 0.02
stop_loss = -0.01
time_limit = 5

# Call triple_barrier_method function
trades = triple_barrier_method(returns, event_dates, profit_taking, stop_loss, time_limit)

# Inspect the trades DataFrame
print(trades)
