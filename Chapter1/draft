library(data.table)

# Assuming you have two data.tables called 'viyy' and 'svxy' with columns 'date' and 'adj_price'
# 'signal' is a separate data.table with columns 'date' and 'signal'

# Merge the viyy and svxy data.tables on 'date' column
merged_data <- merge(viyy, svxy, by = "date", all = TRUE)

# Merge the signal data.table with merged_data on 'date' column
merged_data <- merge(merged_data, signal, by = "date", all = TRUE)

# Calculate the 1-year moving average for the signal
merged_data[, signal_ma := frollmean(signal, n = 252, align = "right", fill = NA)]

# Extract the last trading day of each week
weekly_data <- merged_data[, .SD[.N], by = .(yearweek(date))]

# Create a function to determine the position
get_position <- function(signal, signal_ma) {
  position <- ifelse(!is.na(signal) & signal < signal_ma, 1,
                     ifelse(!is.na(signal) & signal > signal_ma, -1, 0))
  return(position)
}

# Apply the function to calculate positions for each row in weekly_data
weekly_data[, position := get_position(signal, signal_ma)]

# Create a function to calculate the portfolio value
calculate_portfolio <- function(position, adj_price_x, adj_price_y) {
  value <- position * ifelse(!is.na(adj_price_x) & !is.na(adj_price_y), adj_price_x + adj_price_y,
                             ifelse(!is.na(adj_price_x), adj_price_x,
                                    ifelse(!is.na(adj_price_y), adj_price_y, 0)))
  return(value)
}

# Apply the function to calculate portfolio values for each row in weekly_data
weekly_data[, value := calculate_portfolio(position, adj_price.x, adj_price.y)]

# Calculate the cumulative returns of the portfolio
weekly_data[, returns := cumsum(value) / sum(abs(value))]

# Print the positions and portfolio data.tables
print(weekly_data[, .(date, position)])
print(weekly_data[, .(date, value, returns)])



We express the value of a leveraged ETF $L$ at time $t$ as a function of the returns of the index, and its leverage ratio $\lambda$"
​
$$
L_t = L_0 \Pi \left(1 + \lambda r_i\right)
$$
​
or 
​
$$
\log \left(\frac{L_t}{L_0}\right) \approx \sum \left(\lambda r_i - \frac{\lambda^2}{2} r^2_i\right)
$$
​
​
Note that $\ln(1+x) \approx x - \frac{1}{2}x^2$. 
​
​
We can do the analogous decompostion of the underlying asset $S$ at time $t$:
​
$$
S_t = S_0 \Pi \left(1 +  r_i\right)
$$
​
$$
\log \left(\frac{S_t}{S_0}\right) \approx \sum \left(r_i - \frac{1}{2} r^2_i\right)
$$
​
We can multiple it by the leverage ratio $\lambda$
​
$$
\lambda \log \left(\frac{S_t}{S_0}\right) \approx \lambda \sum \left(r_i - \frac{1}{2} r^2_i\right)
$$
​
Consider 
​
$$
\ln \left(\frac{L_t}{L_0}\right) - \lambda \ln \left(\frac{S_t}{S_0}\right) \approx -\frac{\lambda^2- \lambda}{2} \sum r^2_i
$$
​
​
Therefore, solving for $L_t$ the value of the leveraged ETF at time $t$, we get
​
$$
L_t \approx L_0 \left(\frac{S_t}{S_0)}\right)^\lambda \exp\left(-\frac{\lambda^2-\lambda}{2}V_t\right)
$$
​
where $V_t =\sum r^2_i$, which is the realised variance of the underlying asset $S$ from time 0 to time $t$.



mult <- 1000
initprc <- 17
initeqty = 1000000000 / 2
oi <- 142761 * 2
leverage = 2


shocks <- seq(0.5, 10, by = 0.5)

result_table <- data.table(
    init_prc = initprc,
    init_eqty = initeqty,
    open_int = oi, 
    lev_ratio = leverage,
    prcshock = shocks
)
result_table[, init_not := abs(lev_ratio) * init_eqty]
result_table[, init_int := round(init_not / (mult * init_prc))]
result_table[, chg_not := init_int * prcshock * mult]
result_table[, ret := prcshock / init_prc]
result_table[, equity := init_eqty * ( 1+ lev_ratio * ret)]
result_table[, new_not := init_not + chg_not]
result_table[, reba_not := lev_ratio * equity - sign(lev_ratio) * new_not]
result_table[, int_buy := round(reba_not / (mult * (init_prc + prcshock)))]
result_table[, reba_oipct := int_buy / open_int]
result_table[, raw_imp := ret]
result_table[, reba_imp := 0.3 * sqrt(reba_oipct)]
result_table[, total_imp := raw_imp + reba_imp ]
result_table[, final_prc := (1+total_imp) * init_prc]
result_table
​


# Calculate the sample covariance matrix
S_r = r.unstack(level=-1).cov().values  # Covariance of stock returns

# Reshape signals into 2D matrix
x_reshaped = x.unstack(level=-1)

# Calculate the sample covariance matrix of the signals
S_x = x_reshaped.cov().values

# Create cross-covariance matrix
S_rx = np.empty((N, M*N))
for i in range(N):
    for j in range(M*N):
        S_rx[i, j] = np.cov(r.loc[(slice(None), i), 'Forward_Returns'], x.iloc[:, j])[0, 1]

# Step 3: Singular Value Decomposition
# Compute the regularized adjusted cross-covariance matrix
Sigma_r_inv_sqrt = np.linalg.inv(sqrtm(S_r))
Sigma_x_inv_sqrt = np.linalg.inv(sqrtm(S_x))
Sigma_tilde_rx = Sigma_r_inv_sqrt @ S_rx @ Sigma_x_inv_sqrt

# Perform SVD
U, s, Vt = svd(Sigma_tilde_rx)

# Step 4: Portfolio Weights Calculation
# Define the investor's risk aversion
gamma = 1.0

# Calculate the portfolio weights matrix A
A = (1 / gamma) * Sigma_x_inv_sqrt @ Vt.T @ np.diag(s) @ U.T @ Sigma_r_inv_sqrt

print("Portfolio weights matrix A:")
print(A)


# Required libraries
library(lubridate)
library(data.table)

# Function to calculate trading days
trading_days <- function(date) {
  # Convert the date to a Date object if it's not already
  if (class(date) != "Date") {
    date <- as.Date(date)
  }
  
  # Calculate the last calendar day of the previous month
  prev_month_end <- date - days(day(date))
  
  # Get a date in the previous month
  prev_month_date <- date - days(day(date) - 1) - months(1)
  
  # Get the sequence of trading dates for the previous month
  prev_month_days <- dateSeq(prev_month_date, prev_month_end)
  
  # Select the last trading day of the previous month
  last_prev_day <- max(prev_month_days)
  
  # Calculate the last calendar day of the current month
  curr_month_end <- date + days(days_in_month(date) - day(date))
  
  # Get the sequence of trading dates for the current month
  curr_month_days <- dateSeq(date, curr_month_end)
  
  # Select the last trading day of the current month
  last_curr_day <- max(curr_month_days)
  
  # Get the sequence of trading dates from the last trading day of the previous month to the last trading day of the current month
  trading_dates <- dateSeq(last_prev_day, last_curr_day)
  
  # Calculate the number of trading days from the last trading day of the previous month
  prev_month_trading <- sum(trading_dates <= date)
  
  # Calculate the number of trading days to the last trading day of the current month
  curr_month_trading <- sum(trading_dates >= date)
  
  # Create a data table with the given date, the number of trading days from the last trading day of the previous month, and the number of trading days to the last trading day of the current month
  dt <- data.table(
    "date" = date, 
    "prev_month_days" = prev_month_trading, 
    "curr_month_days" = curr_month_trading
  )
  
  return(dt)
}






# Import necessary libraries
import numpy as np
import pandas as pd
import lightgbm as lgb
from sklearn.model_selection import train_test_split

# Suppose X is the stock characteristics and y is the forward stock returns
X = ...  # Load or compute your features here
y = ...  # Load or compute your labels here

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create a LightGBM dataset for training
train_data = lgb.Dataset(X_train, label=y_train)

# Specify the configuration of the model
params = {
    'objective': 'lambdarank',
    'metric': 'ndcg',
    'ndcg_eval_at': [1, 5, 10],
    'learning_rate': 0.1,
    'num_leaves': 31,
    'min_data_in_leaf': 30,
    'num_iterations': 100,
    'verbose': 1
}

# Train the model
model = lgb.train(params, train_data)

# Predict the scores for the test data
y_pred = model.predict(X_test)

# Rank the stocks based on the predicted scores
rankings = np.argsort(y_pred)[::-1]  # Indices of stocks sorted by their scores



# Import necessary libraries
import pandas as pd
from dateutil.relativedelta import relativedelta
import lightgbm as lgb

# Assume X and Y are your dataframes with date, ticker, characteristics, and forward returns
X.sort_values(by=['date', 'ticker'], inplace=True)
Y.sort_values(by=['date', 'ticker'], inplace=True)

# Initialize the LTR model, e.g., LambdaRank in LightGBM
params = {
    'objective': 'lambdarank',
    'metric': 'ndcg',
    'learning_rate': 0.1,
    'num_leaves': 31,
    'min_data_in_leaf': 30,
    'num_iterations': 100,
    'verbose': 1
}
gbm = lgb.LGBMRanker(**params)

# Get unique dates
dates = sorted(X['date'].unique())

# Define the training and prediction window lengths
train_win = relativedelta(months=25)
pred_win = relativedelta(months=1)

# Loop over the dates in the dataset
for i in range(len(dates)):
    # Get the current date
    curr_date = dates[i]

    # Define the start and end dates of the training window
    train_start = curr_date - train_win - pred_win
    train_end = curr_date - pred_win

    # Define the start and end dates of the prediction window
    pred_start = curr_date
    pred_end = curr_date + pred_win

    # Select the training data for the current window
    X_train = X[(X['date'] >= train_start) & (X['date'] < train_end)]
    y_train = Y[(Y['date'] >= train_start) & (Y['date'] < train_end)]['forward_return']

    # Train the model on the current window of data
    gbm.fit(X_train.drop(['date', 'ticker'], axis=1), y_train, group=[X_train.shape[0]])

    # Select the data for the prediction window
    X_pred = X[(X['date'] >= pred_start) & (X['date'] < pred_end)]

    # Predict the scores for the prediction window
    y_pred = gbm.predict(X_pred.drop(['date', 'ticker'], axis=1))

    # Rank the stocks based on the predicted scores
    ranks = pd.Series(y_pred, index=X_pred['ticker']).sort_values(ascending=False)

    # Use the ranks to construct your portfolio for the next period
    # ...

