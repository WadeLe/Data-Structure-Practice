library(data.table)

# Assuming you have two data.tables called 'viyy' and 'svxy' with columns 'date' and 'adj_price'
# 'signal' is a separate data.table with columns 'date' and 'signal'

# Merge the viyy and svxy data.tables on 'date' column
merged_data <- merge(viyy, svxy, by = "date", all = TRUE)

# Merge the signal data.table with merged_data on 'date' column
merged_data <- merge(merged_data, signal, by = "date", all = TRUE)

# Calculate the 1-year moving average for the signal
merged_data[, signal_ma := frollmean(signal, n = 252, align = "right", fill = NA)]

# Extract the last trading day of each week
weekly_data <- merged_data[, .SD[.N], by = .(yearweek(date))]

# Create a function to determine the position
get_position <- function(signal, signal_ma) {
  position <- ifelse(!is.na(signal) & signal < signal_ma, 1,
                     ifelse(!is.na(signal) & signal > signal_ma, -1, 0))
  return(position)
}

# Apply the function to calculate positions for each row in weekly_data
weekly_data[, position := get_position(signal, signal_ma)]

# Create a function to calculate the portfolio value
calculate_portfolio <- function(position, adj_price_x, adj_price_y) {
  value <- position * ifelse(!is.na(adj_price_x) & !is.na(adj_price_y), adj_price_x + adj_price_y,
                             ifelse(!is.na(adj_price_x), adj_price_x,
                                    ifelse(!is.na(adj_price_y), adj_price_y, 0)))
  return(value)
}

# Apply the function to calculate portfolio values for each row in weekly_data
weekly_data[, value := calculate_portfolio(position, adj_price.x, adj_price.y)]

# Calculate the cumulative returns of the portfolio
weekly_data[, returns := cumsum(value) / sum(abs(value))]

# Print the positions and portfolio data.tables
print(weekly_data[, .(date, position)])
print(weekly_data[, .(date, value, returns)])



We express the value of a leveraged ETF $L$ at time $t$ as a function of the returns of the index, and its leverage ratio $\lambda$"
​
$$
L_t = L_0 \Pi \left(1 + \lambda r_i\right)
$$
​
or 
​
$$
\log \left(\frac{L_t}{L_0}\right) \approx \sum \left(\lambda r_i - \frac{\lambda^2}{2} r^2_i\right)
$$
​
​
Note that $\ln(1+x) \approx x - \frac{1}{2}x^2$. 
​
​
We can do the analogous decompostion of the underlying asset $S$ at time $t$:
​
$$
S_t = S_0 \Pi \left(1 +  r_i\right)
$$
​
$$
\log \left(\frac{S_t}{S_0}\right) \approx \sum \left(r_i - \frac{1}{2} r^2_i\right)
$$
​
We can multiple it by the leverage ratio $\lambda$
​
$$
\lambda \log \left(\frac{S_t}{S_0}\right) \approx \lambda \sum \left(r_i - \frac{1}{2} r^2_i\right)
$$
​
Consider 
​
$$
\ln \left(\frac{L_t}{L_0}\right) - \lambda \ln \left(\frac{S_t}{S_0}\right) \approx -\frac{\lambda^2- \lambda}{2} \sum r^2_i
$$
​
​
Therefore, solving for $L_t$ the value of the leveraged ETF at time $t$, we get
​
$$
L_t \approx L_0 \left(\frac{S_t}{S_0)}\right)^\lambda \exp\left(-\frac{\lambda^2-\lambda}{2}V_t\right)
$$
​
where $V_t =\sum r^2_i$, which is the realised variance of the underlying asset $S$ from time 0 to time $t$.



mult <- 1000
initprc <- 17
initeqty = 1000000000 / 2
oi <- 142761 * 2
leverage = 2


shocks <- seq(0.5, 10, by = 0.5)

result_table <- data.table(
    init_prc = initprc,
    init_eqty = initeqty,
    open_int = oi, 
    lev_ratio = leverage,
    prcshock = shocks
)
result_table[, init_not := abs(lev_ratio) * init_eqty]
result_table[, init_int := round(init_not / (mult * init_prc))]
result_table[, chg_not := init_int * prcshock * mult]
result_table[, ret := prcshock / init_prc]
result_table[, equity := init_eqty * ( 1+ lev_ratio * ret)]
result_table[, new_not := init_not + chg_not]
result_table[, reba_not := lev_ratio * equity - sign(lev_ratio) * new_not]
result_table[, int_buy := round(reba_not / (mult * (init_prc + prcshock)))]
result_table[, reba_oipct := int_buy / open_int]
result_table[, raw_imp := ret]
result_table[, reba_imp := 0.3 * sqrt(reba_oipct)]
result_table[, total_imp := raw_imp + reba_imp ]
result_table[, final_prc := (1+total_imp) * init_prc]
result_table
​


# Calculate the sample covariance matrix
S_r = r.unstack(level=-1).cov().values  # Covariance of stock returns

# Reshape signals into 2D matrix
x_reshaped = x.unstack(level=-1)

# Calculate the sample covariance matrix of the signals
S_x = x_reshaped.cov().values

# Create cross-covariance matrix
S_rx = np.empty((N, M*N))
for i in range(N):
    for j in range(M*N):
        S_rx[i, j] = np.cov(r.loc[(slice(None), i), 'Forward_Returns'], x.iloc[:, j])[0, 1]

# Step 3: Singular Value Decomposition
# Compute the regularized adjusted cross-covariance matrix
Sigma_r_inv_sqrt = np.linalg.inv(sqrtm(S_r))
Sigma_x_inv_sqrt = np.linalg.inv(sqrtm(S_x))
Sigma_tilde_rx = Sigma_r_inv_sqrt @ S_rx @ Sigma_x_inv_sqrt

# Perform SVD
U, s, Vt = svd(Sigma_tilde_rx)

# Step 4: Portfolio Weights Calculation
# Define the investor's risk aversion
gamma = 1.0

# Calculate the portfolio weights matrix A
A = (1 / gamma) * Sigma_x_inv_sqrt @ Vt.T @ np.diag(s) @ U.T @ Sigma_r_inv_sqrt

print("Portfolio weights matrix A:")
print(A)
